{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import Parser from \"tree-sitter\";\nimport ShopwareTwig from \"tree-sitter-shopware-twig\";\n\ntype Tree = {\n  rootNode: TemplateNode;\n};\n\ntype TemplateNode = {\n  type: \"template\";\n  children: TwigStatementDirectiveNode[];\n};\n\ntype TwigStatementDirectiveNode = {\n  type: \"twig_statement_directive\";\n  tag: TwigTagNode;\n  variable: TwigVariableNode;\n  children: TwigStatementDirectiveNode[];\n};\n\ntype TwigTagNode = {\n  type: \"twig_tag\";\n  name: string;\n};\n\ntype TwigVariableNode = {\n  type: \"twig_variable\";\n  content: string;\n};\n\nconst parser = new Parser();\n// @ts-expect-error\nparser.setLanguage(ShopwareTwig);\n\nexport function parse(content: string): Tree {\n  const tree = parser.parse(content);\n\n  function convertNode(\n    node: any\n  ): { type: \"block\" | \"endblock\"; name?: string } | null {\n    if (node.type === \"statement_directive\") {\n      const tagStatement = node.children.find(\n        (child: any) => child.type === \"tag_statement\"\n      );\n      if (tagStatement) {\n        const tagNode = tagStatement.children.find(\n          (child: any) => child.type === \"tag\"\n        );\n        const variableNode = tagStatement.children.find(\n          (child: any) => child.type === \"variable\"\n        );\n\n        if (tagNode && tagNode.text === \"block\" && variableNode) {\n          return {\n            type: \"block\",\n            name: variableNode.text,\n          };\n        } else if (tagNode && tagNode.text === \"endblock\") {\n          return {\n            type: \"endblock\",\n          };\n        }\n      }\n    }\n    return null;\n  }\n\n  // First pass: convert all nodes to intermediate format\n  const rawNodes: { type: \"block\" | \"endblock\"; name?: string }[] = [];\n  for (const child of tree.rootNode.children) {\n    const converted = convertNode(child);\n    if (converted) {\n      rawNodes.push(converted);\n    }\n  }\n\n  // Second pass: build nested structure using a stack\n  function buildNestedStructure(\n    nodes: { type: \"block\" | \"endblock\"; name?: string }[]\n  ): TwigStatementDirectiveNode[] {\n    const result: TwigStatementDirectiveNode[] = [];\n    const stack: TwigStatementDirectiveNode[] = [];\n\n    for (const node of nodes) {\n      if (node.type === \"block\") {\n        const blockNode: TwigStatementDirectiveNode = {\n          tag: {\n            type: \"twig_tag\",\n            name: \"block\",\n          },\n          type: \"twig_statement_directive\",\n          variable: {\n            type: \"twig_variable\",\n            content: node.name!,\n          },\n          children: [],\n        };\n\n        if (stack.length > 0) {\n          // Add to the current parent's children\n          stack[stack.length - 1]?.children.push(blockNode);\n        } else {\n          // Add to root level\n          result.push(blockNode);\n        }\n\n        // Push to stack for nesting\n        stack.push(blockNode);\n      } else if (node.type === \"endblock\") {\n        // Pop from stack when we encounter an endblock\n        stack.pop();\n      }\n    }\n\n    return result;\n  }\n\n  const children = buildNestedStructure(rawNodes);\n\n  return {\n    rootNode: {\n      type: \"template\",\n      children,\n    },\n  };\n}\n"]}